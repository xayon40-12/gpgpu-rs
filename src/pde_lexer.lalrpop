use std::str::FromStr;
use crate::integrators::pde_ir::{DiffDir::*,DimDir,ir_helper::*,lexer_compositor::*};
use crate::functions::fix_newton;

grammar(vars: &[DPDE], fun_len: usize, gd: usize); // (var name, bourndary function name, dim)

pub Expr: LexerComp = {
    <l:Expr> "+" <r:Factor> => l + r,
    <l:Expr> "-" <r:Factor> => l - r,
    Factor,
};

Factor: LexerComp = {
    <l:Factor> "*" <r:Pow> => l * r,
    <l:Factor> "/" <r:Pow> => l / r,
    Pow,
};

Pow: LexerComp = {
    <l:Func> "^" <r:Pow> => l ^ r,
    Func,
};

Func: LexerComp = {
    "fix" <params:("[" <Num> "," <Num> "]")?> "(" <f:r"[a-zA-Z]\w*"> <vals:("," <Expr>)*> ")" => {
          let novec = |mut i: Vec<String>| if i.len() > 1 {
              panic!("Expected single value, found Vect.");
          } else {
              i.pop().unwrap()
          };
          compact(vals).fuse_apply(|p,len| {
                let p = p.into_iter().map(|i| novec(i.to_ocl())).collect::<Vec<_>>();
                let next = p.iter().map(|i| &i[..]).collect::<Vec<&str>>();
                let (e,max_iter) = if let Some((e,max_iter)) = params {
                    (e,max_iter as i32)
                } else {
                    (1e-3,1000)
                };
                let name = format!("_{}_fix", fun_len+len);
                let fix = fix_newton(&name,f,&next[..],e,max_iter);
                LexerComp {
                    token: func(&name, next),
                    funs: vec![fix],
                }
          })
    },
    <name:r"[a-zA-Z]\w*"> "(" <mut vals:(<Expr> ",")*> <end:Expr> ")" => {vals.push(end); compact(vals).apply(|i| func(name, i))},
    <d:r"#[<>]?x?y?z?(\^ *[0-9]+)?"> <v:Term> => {
        let (start,n,dirs) = if d.len() > 1 {
            let (start,s) = if &d[1..2] == ">" { (0,2) } else if &d[1..2] == "<" { (1,2) } else { (0,1) };
            let (e,n) = match d.find("^") {
                Some(e) => (e,d[e+1..].parse::<usize>().unwrap()),
                None => (d.len(),1)
            };
            let dirs = d[s..e].chars().map(|c| match c {
                'x' => DimDir::X,
                'y' => DimDir::Y,
                'z' => DimDir::Z,
                a @ _ => panic!("Character '{}' not expected in Func lexer for diff regex.",a)
            }).collect::<Vec<_>>();
            (start,n,dirs)
        } else {
            (0,1,vec![])
        };
        (0..n).fold(v, |v,i| v.apply(|v| diff(v, if (i+start)%2 == 0 { Forward(dirs.clone()) } else { Backward(dirs.clone()) })))
    },
    Term,
};

Term: LexerComp = {
    Num => <>.into(),
    Symb,
    "(" <Expr> ")",
    "[" <s:Expr> <mut t:("," <Expr>)+> "]" => {t.insert(0,s); compact(t).apply(|i| Vect(i))},
    "[" <s:Expr> <mut t:(";" <Expr>)+> "]" => {t.insert(0,s); compact(t).apply(|i| Vect(i))},
};

Symb: LexerComp = {
    r"[a-zA-Z]\w*" => vars.iter().fold(symb(<>),
        |acc,DPDE{var_name: v, boundary: b, var_dim: d, vec_dim: vd}| if <> == v { if *vd>1 { Indexable::new_vector(*d,gd,*vd,&v,&b) } else { Indexable::new_scalar(*d,gd,&v,&b) } } else { acc }).into(),
};

Natural: f64 = {
    r"[0-9]+(e-?[0-9]+)?" => f64::from_str(<>).unwrap(),
};

Negative: f64 = {
    r"-[0-9]+(e-?[0-9]+)?" => f64::from_str(<>).unwrap(),
};

Relative: f64 = {
    Natural,
    Negative,
};

Real: f64 = {
    r"-?[0-9]+\.[0-9]+(e-?[0-9]+)?" => f64::from_str(<>).unwrap(),
};

Num: f64 = {
    Real,
    Relative,
};
